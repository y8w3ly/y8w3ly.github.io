---
layout: post
title: L3akCTF2025
date: 2025-07-14
categories: [Crypto,Hash Cracking,Misc]
tags: [LLL,babai,continued fractions,hashcat]
img_path: /assets/img/L3ak25
image:
  path: /assets/img/L3ak25/icon.png
---

 Last weekend, I participated in L3akCTF2025 and solved some Crypto challenges ,and those are my writeups for most of the challenges I solved.


# Crypto/Dumber
![Dumber](/assets/img/L3ak25/dumber.png)

## Challenge Overview

- **Category**: Crypto
- **Name** : Dumber
- **Points**: 50 (147 solves)
- **Description**: Don't try to outsmart me buddy.


## TL;DR

In this challenge, we’re given two elliptic curve points derived by multiplying parts of the flag (converted to integers) with random points on a hidden elliptic curve. Our job is to recover the modulus and curve coefficients, then perform discrete logarithms to extract the flag.

## Initial Analysis

+ We're provided a Python file `chall.py` that generates two elliptic curve points

```python
from Crypto.Util.number import  bytes_to_long, long_to_bytes
from sage.all import *
a,b,p = REDACTED,REDACTED,REDACTED
pt1="L3AK{REDACTED"
pt2="REDACTED}"
E = EllipticCurve(Zmod(p), [a, b])
p,q=E.random_element(),E.random_element()
u=bytes_to_long(pt1.encode())*p
v=bytes_to_long(pt2.encode())*q
# I will help u <3
print(p,u,q,v)
```

+ So we have `u = pt1 * p` and `v = pt2 * q` where `pt1` and `pt2` are halfs of the flag, and `p`,`q` are random elliptic curve points on a hidden curve `E` over a finite field of an uknown prime.

+ We're also provided the `output.txt` that contains the printed values.

```
(103905521866731574234430443362297034336 : 116589269353056499566212456950780999584 : 1) 

(171660318017081135625337806416866746485 : 122407097490400018041253306369079974706 : 1) 

(161940138185633513360673631821653803879 : 167867902631659599239485617419980253311 : 1) 

(95406403280474692216804281695624776780 : 109560844064302254814641159241201048462 : 1)
```

## Task Analysis

### Given

+ Coordinates of 4 points supposedly lying on an unknown elliptic curve over a finite field.
+ Two of them are the result of scalar multiplication: `u = pt1 × p`, `v = pt2 × q`.

### Goal

+ Recover a,b and the prime.
+ Solve the dlp to get the two parts of the flag and decode them into bytes to get the flag.


## Exploitation

### 1. Recover the modulus

+ we all know that elliptic curves over finite fields satisfy the equation: `y^2 ≡ x^3 + ax + b [p]`.
+ given that `p` and `q` lies on the curve then `y^2 - x^3 ≡ ax + b [p]`for any point on the curve. 
+ so now lets take three points and compute `ri = yi^2 - xi ^3`, so we'll have : 
-`r1 ≡ ax1 + b [p]`
-`r2 ≡ ax2 + b [p]`
-`r3 ≡ ax3 + b [p]`
+ lets substract equations `r1-r2` and `r2-r3`:
- `r1 - r2 ≡ a(x1 - x2) [p]`
- `r2 - r3 ≡ a(x2 - x3) [p]`
+ then we'll have `(r₁ - r₂)/(x₁ - x₂) ≡ a [p]`, so in theory, this gives us `a`, but we don’t yet know `p`, so we can’t do this directly. However, if we build certain expressions from these `ri` they must vanish modulo `p`.
+ To get rid of both `a` and `b`, we construct the following expression : `xi * (rj - rk) + xj * (rk - ri) + xk * (ri - rj) ≡ 0 [p]`
+ if we do this for two or more points we can calculate their pgcd and get p.

### 2. Recover Curve Coefficients `a` and `b`

+ with `p` known, plug in the coordinates of two points into the elliptic curve equation to form two equations: 
- `r1 = y1^2 - x1^3 ≡ a*x1 + b [p]`
- `r2 = y2^2 - x2^3 ≡ a*x2 + b [p]`

+ Solving this simple linear system gives `a` and `b`, such as :
- `a = ((r1 - r2) * ((x1 - x2)^(-1) % p)) % p`
- `b = (r1 - a * x1) % p`

### 3. Rebuild the Curve and Points

+ With p, a, b known, reconstruct the elliptic curve over `GF(p)` and re-create the points `p`,`u`,`v`,`q` 
            `E = EllipticCurve(GF(p), [a, b])`

### 4. Solve the Discrete Logarithm Problem

Using sagemath's `.log()` is enough to solve the ecdlp cuz the group order is small enough.
So : 
+ `pt1 = u.log(p)`
+ `pt2 = v.log(q)`

## Conclusion

Here is the full solve script : 

```python
from Crypto.Util.number import long_to_bytes
from sage.all import *


coords = [
    (103905521866731574234430443362297034336, 116589269353056499566212456950780999584),
    (171660318017081135625337806416866746485, 122407097490400018041253306369079974706),
    (161940138185633513360673631821653803879, 167867902631659599239485617419980253311),
    (95406403280474692216804281695624776780, 109560844064302254814641159241201048462)
]
def expr(i, j, k):
    xi, yi = coords[i]
    xj, yj = coords[j]
    xk, yk = coords[k]
    ri = yi**2 - xi**3
    rj = yj**2 - xj**3
    rk = yk**2 - xk**3
    return xi*(rj - rk) + xj*(rk - ri) + xk*(ri - rj)




exprs = [abs(expr(i, j, k))
        for i in range(len(coords))
        for j in range(i+1, len(coords))
        for k in range(j+1, len(coords))]


p_mod = exprs[0]
for d in exprs[1:]:
    p_mod = gcd(p_mod, d)


x1, y1 = coords[0]
x2, y2 = coords[1]

r1 = (y1**2 - x1**3) % p_mod
r2 = (y2**2 - x2**3) % p_mod

a = ((r1 - r2) * inverse_mod(x1 - x2, p_mod)) % p_mod

b = (r1 - a * x1) % p_mod

E = EllipticCurve(GF(p_mod), [a, b])

p = E(coords[0])
u = E(coords[1])
q = E(coords[2])
v = E(coords[3])


pt1 = u.log(p)
pt2 = v.log(q)
flag = long_to_bytes(pt1) + long_to_bytes(pt2)
print(flag)

```

Finally “Dumber” is anything but dumb.

